[
  {
    "name": "plx-create-todo-plan",
    "text": "I have written down a sequence of // TODO(AI-AGENT) in this project. The goal of this is to provide you with enough information so you can create a prompt that we can use to ask another agent to create a plan for us. Please scan the project for specific // TODO(AI-AGENT) comments and prepare a summary of changes and a prompt for further action. Follow these steps:\n\n1. Use the grep command to search for // TODO(AI-AGENT) comments in the entire project.\n\n2. Sort the results in logical order. Used this to get a good understanding of what the end goal(s) is/are. Once the TODOs are clear, research the project thoroughly until you have 100% perfect plan and understanding exactly how to approach this.\n\n3. Then create a plan of general instructions to achieve our end goal(s). Show this plan in <preparation> brackets in the output. Then instead of writing down an exact plan, present a list of all the files (in glob style) that will be relevant for the agent that will be creating the actual plan. So besides the files that have the comments, think of all the other files that might be relevant for the planning agent to know so it's has enough context to create the perfect plan.\n\n4. Formulate a prompt for another agent to create a plan based on the TODOs. This prompt should assume and mention that the planning agent will receive:\n   - A file map of all relevant files enclosed in <file_map> tags\n   - The current contents of those files enclosed in <file_contents> tags\n\n5. Present your final output in a single markdown code block containing:\n   a. The alphabetic list blob patterns covering all relevant files we should present to the planner\n   b. The exact prompt for the planning agent\n\nYour final output should look like this:\n\n<output>\n```markdown\n# Files involved:\n[list of modified files]\n\n# Prompt for planning agent:\n[Prompt]\n```\n</output>\n\nRemember to include only your <preparation> the markdown code block in your final output, without any additional explanation or commentary.\n\nDon't forget to mention:\n   - the planning agent will receive a file map of all relevant files enclosed in <file_map> tags\n   - the planning agent will receive the current contents of those files enclosed in <file_contents> tags\n\nDO NOT MENTION THE TODO'S ITSELF. FOCUS ON CREATING A COPY PASTE READY OUTPUT WE CAN PRESENT TOWARDS THE PLANNING AGENT. BE SPECIFIC IN YOUR PROMPT ABOUT OUR END GOAL AND RELEVANT CONTEXT WE PROVIDE.\n\nDO NOT TALK ABOUT THE STRUCTURE OF THE PLAN, WE WILL PROVIDE THAT SEPARATELY, NOT OF YOUR CONCERN. FOCUS PURELY ON THE REQUEST, CONTEXT AND SPECIFIC INSTRUCTIONS.\n\nAfter presenting your output ask the user whether you should clean up the // TODO(AI-AGENT), when user confirms proceed to do so.",
    "keyword": "plx-create-todo-plan"
  },
  {
    "name": "plx-ask-for-a-code-review",
    "text": "Based on all the work that you have done, please request a code review in the form of a prompt towards a highly capable agent. Include what this project is about, what your work is about and exactly what you have done. Put your request in a markdown code block for easy copy pasting.",
    "keyword": "plx-ask-for-a-code-review"
  },
  {
    "name": "plx-create-tests",
    "text": "Please create the following tests:\n\n<tests>\n{argument name=\"{{LIST_OF_TESTS}}\"}\nOnly create tests that confirm the core functionality of the feature. Do not create tests for edge cases, error flows or anything else that does not directly confirm just and only the core functionality.\n</tests>\n\n1. Create all tests.\n2. Run all new and project existing tests together by typing `pew test`.\n3. For every failed test provide the following:\n\n<format>\n# üìù Activity: {argument name=\"{{ACTOR_VERB}}\"}\nüíé Expected: {argument name=\"{{EXPECTED}}\"}\nüß± Actual: {argument name=\"{{ACTUAL}}\"}\nüí≠ Reason: {argument name=\"{{WHY_IT_FAILED}}\"}\nüîß Proposed Fix: {argument name=\"{{CODE_SNIPPET}}\"}\n</format>\n\nAfter reporting the test results wait for further instructions on how to proceed.\n\n---\n\n# üë§ Actors & üß© Components (Who or what)\n> - Someone or something that can perform actions or be interacted with (examples include User, Button, Screen, Input Field, Message, System, API, Database, and they can be a person, service, visual or non-visual).\n\n# üé¨ Activities (Who or what does what?)\n> - Actions that an Actor or Component performs (examples include Create List, Delete Item, Sync Data, and they must always contain a verb + action).",
    "keyword": "plx-create-tests"
  },
  {
    "name": "plx-create-tutorial",
    "text": "You are now an AI assistant specializing in creating 'Monkey See Monkey Do' documentation and tutorials based on recently completed work. Your task is to review the work that has been done and then create a clear, straightforward tutorial in markdown format.\n\nFirst, carefully review the completed work:\n<completed_work>\n{argument name=\"{{COMPLETED_WORK}}\"}\n</completed_work>\n\nNow, you will create a tutorial based on this work. The user will provide a specific request for the tutorial:\n<tutorial_request>\n{argument name=\"{{TUTORIAL_REQUEST}}\"}\n</tutorial_request>\n\nWhen creating the tutorial, follow these guidelines:\n\n1. Start with an introduction that clearly explains what is being taught.\n2. Use a neutral, professional tone. Avoid jokes, emojis, or unnecessary clutter. Use simple language so everyone can understand.\n3. Structure the tutorial with clear, logical steps. Each step should be at least one sentence long.\n4. Include relevant code snippets and examples where appropriate.\n5. If applicable, add placeholders for screenshots using the format: [Screenshot: Description of what the screenshot should show]\n6. Ensure the tutorial is straightforward and not convoluted.\n7. Write in a natural style that sounds like a high-quality tutorial found on a reputable website.\n8. Focus on explaining what happens, what needs to be done, and what steps need to be taken.\n\nFormat your tutorial in markdown, including appropriate headings, code blocks, and lists as needed.\n\nVery Important:\n\n- When relevant scripts are available include the complete scripts. This is a 'Monkey See Monkey Do' tutorial. People need to be able to copy our code exactly!\n- When relevant code is available include the complete code snippet. This is a 'Monkey See Monkey Do' tutorial. People need to be able to copy our code exactly!\n- Put the tutorial in a markdown file in the root with a proper name.",
    "keyword": "plx-create-tutorial"
  },
  {
    "name": "plx-create-plan",
    "text": "You are tasked with creating a comprehensive plan to achieve a specific outcome and meet certain end goals. Follow your system instructions carefully to develop an effective and actionable plan.\n\nBegin by reviewing the request and deliverables:\n\n<user_request>\n{argument name=\"{{USER_REQUEST}}\"}\n</user_request>\n\n- VERY IMPORTANT: If the full plan needs more than 5k in context output then split your output up in multiple answers with a token output of 5k max each. Where each part builds on the previous one. I will manually copy paste all the parts into a unified file. All I need from you is the output, divided in answers or max 5k tokens. Each answer should be a markdown code block containing ONLY that part of the plan.\n- Upon me saying 'next' you can output the next part of the plan.\n- Never type things like ‚Äúor similar‚Äù or ‚Äúsomething like that‚Äù. We need to ensure all our agents make the same decisions and build on the same thing after each other.\n- Adhere to this workflow:\n    - PLAN\n        1. Start by researching the current codebase to get a proper understanding of the project.\n        2. Ask the user numbered questions so you are 100% sure about each part of the implementation.\n        3. Upon reaching 100% certainty present the user a global outline of milestones.\n        4. Process feedback of the user.\n    - ACT\n        1. Follow your system instructions for each part of the plan and output the plan per instructions and response template.\n\nSo remember:\n- Split the plan up if needed.\n- Start with researching the codebase.\n- Ask questions to achieve 100% certainty.\n- Proces feedback.\n- Output plan in markdown codeblock(s).\n- End your answer with a numbered list of of all parts of the plan. \n- Adhere to your system instructions and response template.",
    "keyword": "plx-create-plan"
  },
  {
    "name": "plx-create-prompt-plan",
    "text": "Please create a series of prompts that can be used to instruct other highly capable AI agents to complete specific steps towards the overall goal. each prompt step should be designed to be completed by a single AI agent and should not exceed one story point in complexity. This is my request:\n\n<user_request>\n{argument name=\"{{USER_REQUEST}}\"}\n</user_request>",
    "keyword": "plx-create-prompt-plan"
  },
  {
    "name": "plx-fix-tests",
    "text": "Please fix the following tests:\n\n<tests>\n{argument name=\"{{LIST_OF_TESTS}}\"}\n</tests>\n\n1. Fix only those tests.\n2. Run all fixed and existing tests together by typing `pew test`.\n3. For every failed test provide the following:\n\n<format>\n# üìù Activity: {argument name=\"{{ACTOR_VERB}}\"}\nüíé Expected: {argument name=\"{{EXPECTED}}\"}\nüß± Actual: {argument name=\"{{ACTUAL}}\"}\nüí≠ Reason: {argument name=\"{{WHY_IT_FAILED}}\"}\nüîß Proposed Fix: {argument name=\"{{CODE_SNIPPET}}\"}\n</format>\n\nAfter reporting the test results wait for further instructions on how to proceed.\n\n---\n\n# üë§ Actors & üß© Components (Who or what)\n> - Someone or something that can perform actions or be interacted with (examples include User, Button, Screen, Input Field, Message, System, API, Database, and they can be a person, service, visual or non-visual).\n\n# üé¨ Activities (Who or what does what?)\n> - Actions that an Actor or Component performs (examples include Create List, Delete Item, Sync Data, and they must always contain a verb + action).\n",
    "keyword": "plx-fix-tests"
  },
  {
    "name": "plx-research-solution",
    "text": "Please research the solution the following problems:\n\n{argument name=\"{{PROBLEMS}}\"}\n\nFollow these instructions to investigate and solve the problem:\n\n1. Analyze the problem description carefully.\n2. Identify all files that might be related to the problem.\n3. Use all the tools at your disposal to investigate the issue. This may include but is not limited to:\n   - Code analysis tools\n   - Log file analyzers\n   - Debugging tools\n   - Performance profilers\n   - Version control system tools\n4. Document your findings as you go, including any relevant code snippets, log entries, or error messages.\n5. Formulate hypotheses about the root cause of the problem and test them systematically.\n6. Continue searching and investigating until you have reached 100% certainty about the solution.\n7. If you encounter any roadblocks or cannot progress further with the available information, only then should you ask for additional information or clarification.\n\nAfter initial research:\n- You must be 100% certain about your solution. If you're not, continue investigating.\n- Do not ask questions unless it's absolutely necessary and you've exhausted all other options.\n- Be thorough and meticulous in your investigation.\n\nProvide your final report in the following format:\n\n<investigation_report>\n<files_analyzed>\nList all files you analyzed during the investigation.\n</files_analyzed>\n\n<tools_used>\nList all tools you used and how they contributed to your investigation.\n</tools_used>\n\n<findings>\nDescribe your key findings, including any relevant code snippets, log entries, or error messages.\n</findings>\n\n<root_cause>\nExplain the root cause of the problem with 100% certainty.\n</root_cause>\n\n<solution>\nProvide a detailed solution to fix the bug.\n</solution>\n\n<certainty_statement>\nExplain why you are 100% certain about your solution.\n</certainty_statement>\n</investigation_report>\n\nIf you cannot reach 100% certainty, do not provide a final report. Instead, explain what additional information or access you would need to reach full certainty, and continue your investigation.",
    "keyword": "plx-research-solution"
  },
  {
    "name": "plx-create-requirements",
    "text": "You are a requirements expert with expertise in understanding complex codebases and project planning. Your task is to provide the detailed requirements template for building out a product or feature based on a user's request. You will analyze the information provided, formulate actors, components, activities, behaviours, goals.\n\nHere is the user's request:\n\n<user_request>\n{argument name=\"{argument name=\"{{USER_REQUEST}}\"}\"}\n</user_request>\n\n<requirements_template>\n## üë§ Actors & üß© Components (Who or what)\n> - Someone or something that can perform actions or be interacted with (examples include User, Button, Screen, Input Field, Message, System, API, Database, and they can be a person, service, visual or non-visual).\n\n> - What benefits from this? ¬∑ Who maintains this? ¬∑ What do users interact with? ¬∑ What shows information? ¬∑ What processes data? ¬∑ What stores data? ¬∑ What external systems are involved? ¬∑ What needs to be monitored?\n\n> - GPT Instructions: Start by listing all nouns from your feature description - these are your potential actors and components. Then expand this list by asking: who uses it, what do they interact with, what shows information, what stores data, and what processes data? For each item, decide if it's an Actor (can perform actions) or Component (is acted upon). Finally, break down any complex components into smaller, more manageable pieces.\n\n> - Possible Parents: Itself\n> - Link actors and components to their (optional) parent by starting with the parent in [square brackets] and the actor(s)/component(s) beneath it. Example:\n> \t- [parent]\n> \t\t- [Actor]\n> \t\t- [Component]\n---\n\n-\n\n## üé¨ Activities (Who or what does what?)\n> - Actions that an Actor or Component performs (examples include Create List, Delete Item, Sync Data, and they must always contain a verb + action).\n\n> - What can each actor do? ¬∑ What should happen automatically? ¬∑ What needs user input? ¬∑ What happens periodically? ¬∑ What triggers other activities? ¬∑ What needs to be logged? ¬∑ What needs to be measured? ¬∑ What needs authorization?\n\n> - GPT Instructions: Take each Actor and Component and list everything they can do, must do, or should do automatically. Start each activity with a verb (create, update, delete, etc.) and make it specific. Think about: user interactions, system automations, periodic tasks, and data operations. Don't worry about the \"how\" yet - focus on what needs to happen.\n\n> - Possible Parents: Actor, Component\n> - Link activities to their parent by starting with the parent in [square brackets] and the activitity beneath it. Example:\n> \t- [parent]\n> \t\t- [Create item]\n> \t\t- [Delete item]\n---\n\n-\n\n## üåä Activity Flows & Scenarios (What in which order?)\n> - Sequences of Atomic Actions (like \"Tap button\") that map out the steps to complete an Activity. May have optional paths for both successful completion (Happy Flow), errors (Error Flow), and scenarios like no connection, empty states, loading states, etc.\n\n> - What's the ideal path? ¬∑ What could fail? ¬∑ What needs validation? ¬∑ What needs confirmation? ¬∑ What's time sensitive? ¬∑ What needs recovery steps? ¬∑ What should be cached? ¬∑ What should be retried? ¬∑ What needs rollback?\n\n> - GPT Instructions: For each Activity think of the perfect scenario (Happy Flow) - what happens when everything works? Then optionally add Error Flows by asking \"what could go wrong?\" at each step. Finally, consider edge cases like no connection, empty states, or loading states. Break each flow into atomic (indivisible) actions that can be clearly implemented and tested. Prefix each atomic action with BDD Gherkin keywords: GIVEN, WHEN, THEN, AND, BUT.\n\n> - Possible Parents: Activities, Itself\n> - Link activity flows to their parent by starting with the parent in [square brackets] and the activity flow(s) beneath it. Example:\n> \t- [parent]\n> \t\t- GIVEN [User] is at [Home Screen]\n> \t\t- WHEN [User] [taps create item button]\n> \t\t- THEN [System] [shows create item feedback]\n> \t\t- AND [System] [creates database item]\n> \t\t- BUT [System] [does not navigate]\n---\n\n-\n\n## üìù Properties (Which values?)\n> - Describes a value or configuration that belongs to an object (examples include width, color, id, name).\n\n> - What identifies it? ¬∑ What describes it? ¬∑ What configures it? ¬∑ What measures it? ¬∑ What styles it? ¬∑ What formats it? ¬∑ What tracks it? ¬∑ What groups it? ¬∑ What orders it?\n\n> - GPT Instructions: For each object in your system, think about its data needs in three categories: identity (what makes it unique), configuration (what can be changed), and state (what can vary). Consider what needs to be stored, displayed, measured, or tracked. Make sure each property has a clear type and purpose.\n\n> - Possible Parents: Actor, Component, Activity, Activity Flow, Scenario, Atomic Action, Scenario, Behaviour\n> - Link properties to their parent by starting with the parent in [square brackets] and the property/properties beneath it. Example:\n> \t- [parent]\n> \t\t- [name : string]\n---\n\n-\n\n## üõ†Ô∏è Behaviours (How does it act when.. in terms of.. ?)\n> - Defines how something looks, works and performs Examples include ui/ux, rules & limits, data & analytics, security, performance and scalability.\n\n> - When should it change? ¬∑ How should it respond? ¬∑ What are the limits? ¬∑ What needs validation? ¬∑ What needs animation? ¬∑ What needs protection? ¬∑ What should be cached? ¬∑ What should be optimized? ¬∑ What should be monitored? ¬∑ What needs fallback? ¬∑ How should it scale? ¬∑ What should be logged? ¬∑ How should it fail? ¬∑ What should be measured? ¬∑ What needs authorization?\n\n> - GPT Instructions: Think about each object's rules and constraints in terms of: limits (max/min values, allowed inputs), timing (when, how often), security (who can access), and performance (what needs to be fast). Focus on behaviours that can be clearly tested - if you can't write a test for it, make it more specific.\n\n> - Possible Parents: Actor, Component, Activity, Activity Flow, Scenario, Atomic Action, Scenario, Property\n> - Link behaviours to their parent by starting with the parent in [square brackets] and the behaviour(s) beneath it. Example:\n> \t- [parent]\n> \t\t- [Should fail when length is 100+ characters]\n> \t\t- [Should not show when list is empty]\n---\n\n-\n</requirements_template>\n\n# Response Format:\n\nPresent your filled in template in a single markdown file with the goal of providing the reader with EVERYTHING they need to know to develop the feature. Use the following markdown response format:\n\n<response_format>\n# Project Plan: [Project Name]\n\n## 1. Original User Request\n\"{argument name=\"{{USER_REQUEST}}\"}\"\n\n## 2. Requirements\nOverview of all requirements.\n\n- üë§ Actors & üß© Components:\n    - [Actors]\n    - [Components]\n- üé¨ Activities: Specify what actions need to be performed.\n    - [Actor]\n        - [Activity]\n    - [Component]\n        - [Activity]\n- üåä Activity Flows & Scenarios: Break down complex activities into step-by-step processes.\n    - [Parent]\n        - [Activity Flow]\n- üìù Properties: Define any values or configurations associated with components or activities.\n    - [Parent]\n        - [Property]\n- üõ†Ô∏è Behaviours: Describe how actors, components, properties, and activities should act or respond in different situations.\n    - [Parent]\n        - [Behaviour]\n</response_format>\n\n# Strict Conventions\n\n- Use MVVM View, ViewModel, Services (single responsibility micro service approach) approach when dealing with front-end otherwise use only single responsibility micro services. More details down below.\n- Single responsibility micro service approach.\n    - You will always create separated services for isolated logic to enforce single responsibility as much as possible. Design every solution with this in mind. This makes our code well-organised, maintainable and easily testable.\n- Use other services in services using dependency injection.\n- Organise your services properly:\n    1. Constructor\n    2. Singleton / Factory locate method\n    3. Dependencies\n    4. Initialise / Dispose methods\n    5. Listeners\n    6. Override methods\n    7. Util variables (debouncers, mutexes, etc)\n    8. State variables\n    9. Fetchers & getters (any methods that returns a value and nothing else)\n    10. Helper methods (any method that is created to help other methods)\n    11. Mutator methods (any method that changes something)\n- Make a service a lazy singletons when one of these is true:\n    - the service is used by more than 1 class\n    - any state inside the service needs to be preserved\n- Single responsibility is extremely important in our solutions. Create separated services for isolated logic to enforce this single responsibility as much as possible.\n- Single responsibility and isolated logic also applies to other parts of the project:\n    - Folder structure\n        - When deciding where to create / organize a file you will adhere to feature/category approach. Example: auth/views, core/commands\n    - Other logic\n        - When creating other classes besides services such as dtos, models, typedefs, requests, responses, forms, widgets, components, enums, exceptions, analytics, apis, repositories:\n            - You will name them by their use and category: examples: AuthView, on_changed_def, create-user-request.\n            - You will make sure these classes also adhere to single responsibilities and try to split up logic to the best of your abilities.\n- Create classes that fall into these categories:\n   - Abstract classes\n   - Services (single responsibility, specify if it's a factory, singleton, or lazy singleton)\n   - ViewModels\n   - DTOs (raw data)\n   - Models (manipulated data)\n- Use proper naming conventions:\n   - FooService, FooViewModel, FooView, FooMixin, FooRouter, FooModel, FooConfig, FooButton, Mutex, Debouncer, FooDef\n   - kVariable for const globals\n   - gVariable for global variables\n   - gMethod() for global methods\n- Use full variable names for improved readability (e.g., superButton instead of button).\n\n# Important Final Remarks\n\nRemember: Provide your complete requirements report in a single markdown file, following the structure and guidelines outlined above.\nDo not output anything else than the <response_format> in markdown in your initial response.",
    "keyword": "plx-create-requirements"
  },
  {
    "name": "plx-develop",
    "text": "You are now an experienced full-stack developer tasked with planning and implementing a project based on a user's request. Your goal is to analyze the request, create a comprehensive plan, and then execute that plan to develop the project.\n\nHere is the user's request:\n\n<user_request>\n{argument name=\"{{USER_REQUEST}}\"}\n</user_request>\n\nFirst, analyze the request and formulate a project plan. Break down your thought process in <project_planning> tags. Follow these steps:\n\n1. Summarize the user's request in your own words\n2. List the key technical requirements\n3. Identify potential challenges and risks\n4. Outline the main components and their interactions\n5. Brainstorm potential solutions and approaches\n6. Prioritize tasks based on importance and dependencies\n7. Conduct a final \"sanity check\" to ensure all aspects of the request are addressed\n\nConsider the following aspects throughout your planning:\n\n1. Main objectives and specific, measurable outcomes\n2. Potential challenges and dependencies\n3. Key technical requirements\n4. Essential components and their interactions\n5. Potential risks and mitigation strategies\n\nAfter your analysis present your analysis and project plan in a single markdown file with the following structure:\n\n```markdown\n# Project Plan: [Project Name]\n\n## 1. Project Overview\nA brief summary of the project, including its main objectives and key features. Clearly state the end goals formulated in your analysis.\n- [ ] Read the project overview:\n    - [Brief summary of the project, including end goals]\n\n## 2. Requirements\nOverview of all requirements.\n- [ ] Read the requirements:\n    - üë§ Actors & üß© Components:\n        - [Actors]\n        - [Components]\n    - üé¨ Activities: Specify what actions need to be performed.\n        - [Actor]\n            - [Activity]\n        - [Component]\n            - [Activity]\n    - üåä Activity Flows & Scenarios: Break down complex activities into step-by-step processes.\n        - [Parent]\n            - [Activity Flow]\n    - üìù Properties: Define any values or configurations associated with components or activities.\n        - [Parent]\n            - [Property]\n    - üõ†Ô∏è Behaviours: Describe how actors, components, properties, and activities should act or respond in different situations.\n        - [Parent]\n            - [Behaviour]\n\n## 3. Milestones and Tasks\nThe project broken down into milestones. Each milestone should be executable by an independent AI developer agent. Each milestone should not exceed 3 story points and should be executable independently. You can assume that each milestone will be offered in a new call by an agent with empty context. However, the executing agent will have access the ticket and thus be able to form an idea about the work that has been done.\n\nEach milestone consists of individual tasks for the unpacking agent. For each task, include:\n    - A one-sentence to one-paragraph description of what needs to be done, starting with a verb.\n    - A sequence diagram of end result.\n    - File names that will be created, read, updated, or deleted (CRUD), using proper naming conventions and casing styles.\n    - Objects/classes that will be CRUDed, including appropriate class keywords (e.g., sealed, abstract).\n    - Variables that will be CRUDed, including types, values, and keywords. Use proper casing and specify whether they are part of a class, method, or global constants.\n    - Methods that will be CRUDed, including return values, input values, and whether they are async/sync.\n    - For any complex processes or setup required to achieve a task or goal, provide clear, step-by-step instructions on how to complete these processes.\n\n\n### Milestone 1: [Milestone Name]\n[Milestone description]\n\n#### Task title\n- [ ] 1. [Task description]\n- Sequence diagram\n    - [ASCII art or textual representation of the sequence diagram]\n- Files:\n    - [List of files]\n- Classes:\n    - [List of classes]\n- Variables:\n    - [List of variables]\n- Methods:\n    - [List of methods]\n- Process:\n    - [Step-by-step instructions for any complex processes]\n\n- [ ] 2. [Next task...]\n\n#### Task title\n- [ ] 1. [Task description]\n- Files:\n    - [List of files]\n- Classes:\n    - [List of classes]\n- Variables:\n    - [List of variables]\n- Methods:\n    - [List of methods]\n- Process:\n    - [Step-by-step instructions for any complex processes]\n\n### Milestone 2: [Milestone Name]\n[Repeat the structure for each milestone]\n```\n\nThen, proceed with the development process, explaining your actions and decisions as you go. Focus on implementing the core functionality and components you've identified in your plan.",
    "keyword": "plx-develop"
  },
  {
    "name": "plx-prepare-handoff",
    "text": "Your work here is done. Please prepare your work for the next developer.\n\n1. Review the current tasks file:\n<tasks_file>\n{argument name=\"{argument name=\"{{TASKS_FILE}}\"}\"}\n</tasks_file>\n\n1. Update the tasks file:\n   - Go through each task in the tasks file with read_file tool.\n   - For any completed tasks, update their status to \"[x]\" (completed) with your edit_file tool.\n   - Do not modify any uncompleted tasks.\n\n2. Create a message for the next developer:\n   - Summarize what has been done so far.\n   - Clearly state the next task to be completed and relevant information to that task for a quick start.\n   - Include a link to the updated tasks file (use {argument name=\"{argument name=\"{{TASKS_FILE}}\"}\"} as the filename).\n   - Output this message inside a code block for easy copy pasting.\n\nEnsure that all your outputs are clear, concise, and directly related to the project at hand. Do not include any extraneous information or commentary.\n\nSummary:\n\n- 1. Update tasks file {argument name=\"{argument name=\"{{TASKS_FILE}}\"}\"}\n- 2. Output message in code block.",
    "keyword": "plx-prepare-handoff"
  },
  {
    "name": "template-for-plans",
    "text": "# Project Plan: [Project Name]\n\n## 1. Project Overview\nA brief summary of the project, including its main objectives and key features. Clearly state the end goals formulated in your analysis.\n- [ ] Read the project overview:\n    - [Brief summary of the project, including end goals]\n\n## 2. Requirements\nOverview of all requirements.\n- [ ] Read the requirements:\n    - üë§ Actors & üß© Components:\n        - [Actors]\n        - [Components]\n    - üé¨ Activities: Specify what actions need to be performed.\n        - [Actor]\n            - [Activity]\n        - [Component]\n            - [Activity]\n    - üåä Activity Flows & Scenarios: Break down complex activities into step-by-step processes.\n        - [Parent]\n            - [Activity Flow]\n    - üìù Properties: Define any values or configurations associated with components or activities.\n        - [Parent]\n            - [Property]\n    - üõ†Ô∏è Behaviours: Describe how actors, components, properties, and activities should act or respond in different situations.\n        - [Parent]\n            - [Behaviour]\n\n## 3. Milestones and Tasks\nThe project broken down into milestones. Each milestone should be executable by an independent AI developer agent. Each milestone should not exceed 3 story points and should be executable independently. You can assume that each milestone will be offered in a new call by an agent with empty context. However, the executing agent will have access the ticket and thus be able to form an idea about the work that has been done.\n\nEach milestone consists of individual tasks for the unpacking agent. For each task, include:\n    - A one-sentence to one-paragraph description of what needs to be done, starting with a verb.\n    - A sequence diagram of end result.\n    - File names that will be created, read, updated, or deleted (CRUD), using proper naming conventions and casing styles.\n    - Objects/classes that will be CRUDed, including appropriate class keywords (e.g., sealed, abstract).\n    - Variables that will be CRUDed, including types, values, and keywords. Use proper casing and specify whether they are part of a class, method, or global constants.\n    - Methods that will be CRUDed, including return values, input values, and whether they are async/sync.\n    - For any complex processes or setup required to achieve a task or goal, provide clear, step-by-step instructions on how to complete these processes.\n\n\n### Milestone 1: [Milestone Name]\n[Milestone description]\n\n#### Task title\n- [ ] 1. [Task description]\n- Sequence diagram\n    - [ASCII art or textual representation of the sequence diagram]\n- Files:\n    - [List of files]\n- Classes:\n    - [List of classes]\n- Variables:\n    - [List of variables]\n- Methods:\n    - [List of methods]\n- Process:\n    - [Step-by-step instructions for any complex processes]\n\n- [ ] 2. [Next task...]\n\n#### Task title\n- [ ] 1. [Task description]\n- Files:\n    - [List of files]\n- Classes:\n    - [List of classes]\n- Variables:\n    - [List of variables]\n- Methods:\n    - [List of methods]\n- Process:\n    - [Step-by-step instructions for any complex processes]\n\n### Milestone 2: [Milestone Name]\n[Repeat the structure for each milestone]",
    "keyword": "template-for-plans"
  }
]